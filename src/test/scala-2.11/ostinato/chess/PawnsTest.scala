package ostinato.chess

import ostinato.chess.core._
import ostinato.core.XY
import org.scalatest.{ ShouldMatchers, FunSpec }

class PawnsTest extends FunSpec with ShouldMatchers {
  describe("Pawns") {
    it("should find 1 possible move for black pawn") {
      val game = ChessGame.fromString(
        """........
          |........
          |..♟.....
          |........
          |........
          |........
          |........
          |........""".stripMargin, turn = BlackChessPlayer)

      game.board.movements.size shouldBe 1
    }

    it("should find 2 possible moves for black pawn") {
      val game = ChessGame.fromString(
        """........
          |..♟.....
          |........
          |........
          |........
          |........
          |........
          |........""".stripMargin, turn = BlackChessPlayer)

      game.board.movements.size shouldBe 2
    }

    it("should find 4 possible moves for black pawn") {
      val game = ChessGame.fromString(
        """........
          |..♟.....
          |.♖.♖....
          |........
          |........
          |........
          |........
          |........""".stripMargin, turn = BlackChessPlayer)

      game.board.movements.size shouldBe 4
    }

    it("should find 3 possible moves for black pawn") {
      val game = ChessGame.fromString(
        """........
          |........
          |..♟.....
          |.♖.♖....
          |........
          |........
          |........
          |........""".stripMargin, turn = BlackChessPlayer)

      game.board.movements.size shouldBe 3
    }

    it("should find 0 possible moves for black pawn") {
      val game = ChessGame.fromString(
        """........
          |..♟.....
          |..♖.....
          |........
          |........
          |........
          |........
          |........""".stripMargin, turn = BlackChessPlayer)

      game.board.movements.size shouldBe 0
    }

    it("should not find black pawn in promoting position") {
      val game = ChessGame.fromString(
        """..♟.....
          |........
          |........
          |........
          |........
          |........
          |........
          |........""".stripMargin, turn = BlackChessPlayer)

      game.blackPlayer.pieces(game.board).head match {
        case p: ♟ ⇒ p.isPromoting shouldBe false
        case _    ⇒ fail
      }
    }

    it("should find black pawn in promoting position") {
      val game = ChessGame.fromString(
        """........
          |........
          |........
          |........
          |........
          |........
          |........
          |..♟.....""".stripMargin, turn = BlackChessPlayer)

      game.blackPlayer.pieces(game.board).head match {
        case p: ♟ ⇒ p.isPromoting shouldBe true
        case _    ⇒ fail
      }
    }

    it("should not find white pawn in promoting position") {
      val game = ChessGame.fromString(
        """........
          |........
          |........
          |........
          |........
          |........
          |........
          |..♙.....""".stripMargin, turn = WhiteChessPlayer)

      game.whitePlayer.pieces(game.board).head match {
        case p: ♟ ⇒ p.isPromoting shouldBe false
        case _    ⇒ fail
      }
    }

    it("should find white pawn in promoting position") {
      val game = ChessGame.fromString(
        """..♙.....
          |........
          |........
          |........
          |........
          |........
          |........
          |........""".stripMargin, turn = WhiteChessPlayer)

      game.whitePlayer.pieces(game.board).head match {
        case p: ♟ ⇒ p.isPromoting shouldBe true
        case _    ⇒ fail
      }
    }

    it("should find the 4 promoting moves for pawn") {
      val game = ChessGame.fromString(
        """........
          |..♙.....
          |........
          |........
          |........
          |........
          |........
          |........""".stripMargin, turn = WhiteChessPlayer)

      game.board.movements.size shouldBe 4
    }

    Map(
      ♛(XY(2, 0), WhiteChessPlayer) -> '♕',
      ♞(XY(2, 0), WhiteChessPlayer) -> '♘',
      ♝(XY(2, 0), WhiteChessPlayer) -> '♗',
      ♜(XY(2, 0), WhiteChessPlayer) -> '♖'
    ) foreach {
      case (piece, char) ⇒
        it(s"should promote to $char") {
          val game = ChessGame.fromString(
            """........
              |..♙.....
              |........
              |........
              |........
              |........
              |........
              |........""".stripMargin, turn = WhiteChessPlayer, fullMoveNumber = 40, halfMoveClock = 0)

          game.board.move(PromoteMovement(♟(XY(2, 1), WhiteChessPlayer, -1), XY(0, -1), piece)) should equal(
            ChessGame.fromString(
              """..x.....
                |........
                |........
                |........
                |........
                |........
                |........
                |........""".stripMargin.replace('x', char), turn = BlackChessPlayer, fullMoveNumber = 40, halfMoveClock = 0).board
          )
        }
    }
  }
}
