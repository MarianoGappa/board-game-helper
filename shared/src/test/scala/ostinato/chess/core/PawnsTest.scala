package ostinato.chess.core

import ostinato.core.XY
import org.scalatest._

class PawnsTest extends FunSpec with Matchers {
  describe("Pawns") {
    it("should find 1 possible action for black pawn") {
      val game = ChessGame.fromGridString(
        """........
          |........
          |..♟.....
          |........
          |........
          |........
          |........
          |........""".stripMargin, turn = BlackChessPlayer).get

      game.board.pieces.head.actions(game.board).size shouldBe 1
    }

    it("should find 2 possible actions for black pawn") {
      val game = ChessGame.fromGridString(
        """........
          |..♟.....
          |........
          |........
          |........
          |........
          |........
          |........""".stripMargin, turn = BlackChessPlayer).get

      game.board.pieces.head.actions(game.board).size shouldBe 2
    }

    it("should find 4 possible actions for black pawn") {
      val game = ChessGame.fromGridString(
        """........
          |..♟.....
          |.♖.♖....
          |........
          |........
          |........
          |........
          |........""".stripMargin, turn = BlackChessPlayer).get

      game.board.pieces.head.actions(game.board).size shouldBe 4
    }

    it("should find 3 possible actions for black pawn") {
      val game = ChessGame.fromGridString(
        """........
          |........
          |..♟.....
          |.♖.♖....
          |........
          |........
          |........
          |........""".stripMargin, turn = BlackChessPlayer).get

      game.board.pieces.head.actions(game.board).size shouldBe 3
    }

    it("should find 0 possible actions for black pawn") {
      val game = ChessGame.fromGridString(
        """........
          |..♟.....
          |..♖.....
          |........
          |........
          |........
          |........
          |........""".stripMargin, turn = BlackChessPlayer).get

      game.board.pieces.head.actions(game.board).size shouldBe 0
    }
  }
  describe("Promoting") {
    it("should not find black pawn in promoting position") {
      val game = ChessGame.fromGridString(
        """..♟.....
          |........
          |........
          |........
          |........
          |........
          |........
          |........""".stripMargin, turn = BlackChessPlayer).get

      game.blackPlayer.pieces(game.board).head match {
        case p: ♟ ⇒ p.isPromoting shouldBe false
        case _    ⇒ fail
      }
    }

    it("should find black pawn in promoting position") {
      val game = ChessGame.fromGridString(
        """........
          |........
          |........
          |........
          |........
          |........
          |........
          |..♟.....""".stripMargin, turn = BlackChessPlayer).get

      game.blackPlayer.pieces(game.board).head match {
        case p: ♟ ⇒ p.isPromoting shouldBe true
        case _    ⇒ fail
      }
    }

    it("should not find white pawn in promoting position") {
      val game = ChessGame.fromGridString(
        """........
          |........
          |........
          |........
          |........
          |........
          |........
          |..♙.....""".stripMargin, turn = WhiteChessPlayer).get

      game.whitePlayer.pieces(game.board).head match {
        case p: ♟ ⇒ p.isPromoting shouldBe false
        case _    ⇒ fail
      }
    }

    it("should find white pawn in promoting position") {
      val game = ChessGame.fromGridString(
        """..♙.....
          |........
          |........
          |........
          |........
          |........
          |........
          |........""".stripMargin, turn = WhiteChessPlayer).get

      game.whitePlayer.pieces(game.board).head match {
        case p: ♟ ⇒ p.isPromoting shouldBe true
        case _    ⇒ fail
      }
    }

    it("should find the 4 promoting actions for pawn") {
      val game = ChessGame.fromGridString(
        """........
          |..♙.....
          |........
          |........
          |........
          |........
          |........
          |........""".stripMargin, turn = WhiteChessPlayer).get

      game.board.pieces.head.actions(game.board).size shouldBe 4
    }

    it("should find distanceToPromotion == 1") {
      val game = ChessGame.fromGridString(
        """........
          |..♙.....
          |........
          |........
          |........
          |........
          |........
          |........""".stripMargin).get

      game.board.pawns.head.distanceToPromotion shouldBe 1
    }

    it("should find distanceToPromotion == 6") {
      implicit val rules = ChessRules.default.copy(whitePawnDirection = 1)
      val game = ChessGame.fromGridString(
        """........
          |..♙.....
          |........
          |........
          |........
          |........
          |........
          |........""".stripMargin).get

      game.board.pawns.head.distanceToPromotion shouldBe 6
    }

    Map(
      ♛(XY(2, 0), WhiteChessPlayer) -> '♕',
      ♞(XY(2, 0), WhiteChessPlayer) -> '♘',
      ♝(XY(2, 0), WhiteChessPlayer) -> '♗',
      ♜(XY(2, 0), WhiteChessPlayer) -> '♖'
    ) foreach {
        case (piece, char) ⇒
          it(s"should promote to $char") {
            val game = ChessGame.fromGridString(
              """........
                |..♙.....
                |........
                |........
                |........
                |........
                |........
                |........""".stripMargin, turn = WhiteChessPlayer, fullMoveNumber = 40, halfMoveClock = 0).get

            game.board.doAction(PromoteAction(♟(XY(2, 1), WhiteChessPlayer, -1), XY(0, -1), piece)).get should equal(
              ChessGame.fromGridString(
                """..x.....
                  |........
                  |........
                  |........
                  |........
                  |........
                  |........
                  |........""".stripMargin.replace('x', char), turn = BlackChessPlayer, fullMoveNumber = 40, halfMoveClock = 0).get.board
            )
          }
      }
  }

  describe("Promoting while capturing") {
    it("should find the 4 capturing+promoting actions for pawn") {
      val game = ChessGame.fromGridString(
        """..♟♞....
          |..♙.....
          |........
          |........
          |........
          |........
          |........
          |........""".stripMargin, turn = WhiteChessPlayer).get

      game.board.actions shouldBe Set(
        LoseAction(WhiteChessPlayer),
        DrawAction(WhiteChessPlayer),
        CapturePromoteAction(♟(XY(2, 1), WhiteChessPlayer, -1), XY(1, -1), ♞(XY(3, 0), BlackChessPlayer), ♛(XY(3, 0), WhiteChessPlayer)),
        CapturePromoteAction(♟(XY(2, 1), WhiteChessPlayer, -1), XY(1, -1), ♞(XY(3, 0), BlackChessPlayer), ♞(XY(3, 0), WhiteChessPlayer)),
        CapturePromoteAction(♟(XY(2, 1), WhiteChessPlayer, -1), XY(1, -1), ♞(XY(3, 0), BlackChessPlayer), ♝(XY(3, 0), WhiteChessPlayer)),
        CapturePromoteAction(♟(XY(2, 1), WhiteChessPlayer, -1), XY(1, -1), ♞(XY(3, 0), BlackChessPlayer), ♜(XY(3, 0), WhiteChessPlayer))
      )
    }
  }
}
